#!/usr/bin/env python

import parmed as pmd
from simtk import openmm as mm, unit as u
from simtk.openmm import app
import numpy as np
import os, re

# Run CHARMM energy and force calculation
import subprocess
print('Running CHARMM in docker container (may take a minute)...')
command = "docker run -i -v `pwd`:/mnt -t omnia/charmm-lite:c40b1 /mnt/dhfr.sh"
charmm_output = subprocess.check_output(command, shell=True)

# Parse CHARMM energy and force output
"""
ENER ENR:  Eval#     ENERgy      Delta-E         GRMS
ENER INTERN:          BONDs       ANGLes       UREY-b    DIHEdrals    IMPRopers
ENER CROSS:           CMAPs        PMF1D        PMF2D        PRIMO
ENER EXTERN:        VDWaals         ELEC       HBONds          ASP         USER
ENER IMAGES:        IMNBvdw       IMELec       IMHBnd       RXNField    EXTElec
ENER EWALD:          EWKSum       EWSElf       EWEXcl       EWQCor       EWUTil
 ----------       ---------    ---------    ---------    ---------    ---------
ENER>        0-163043.99835      0.00000      5.02279
ENER INTERN>     6337.99813   4236.12181     54.30685   1726.66813     21.86301
ENER CROSS>       -21.48984      0.00000      0.00000      0.00000
ENER EXTERN>    20161.20647-164737.82886      0.00000      0.00000      0.00000
ENER IMAGES>      243.39096  -5318.48694      0.00000      0.00000      0.00000
ENER EWALD>       4130.5989-1021718.0599  991839.7129       0.0000       0.0000
"""
print('Parsing CHARMM output...')
keys = list()
values = list()
for line in charmm_output.split('\n'):
    if line.startswith('ENER'):
        if ':' in line:
            elements = line.split(':')
            tokens = elements[1].split()
            for token in tokens:
                token = token.strip()
                keys.append(token)
        elif '>' in line:
            elements = line.split('>')
            tokens = re.split('(-|\+)|\s+', elements[1].strip())
            index = 0
            while index < len(tokens):
                if (tokens[index] is None) or (len(tokens[index])==0):
                    index += 1
                elif tokens[index] in ['+', '-']:
                    token = (tokens[index] + tokens[index+1]).strip()
                    value = float(token)
                    index += 2
                    values.append(value)
                else:
                    token = tokens[index].strip()
                    value = float(token)
                    index += 1
                    values.append(value)

from collections import OrderedDict
charmm_energy_components = OrderedDict()
for (key, value) in zip(keys, values):
    charmm_energy_components[key] = value
print(charmm_energy_components)

# Read forces
" CHARMM>    PRINT COOR COMP"
"""
 CHARMM>    PRINT COOR COMP

          COORDINATE FILE MODULE
 TITLE>  * GENERATED BY CHARMM-GUI (HTTP://WWW.CHARMM-GUI.ORG) V1.8 ON MAY, 05. 2016.
 TITLE>  * INPUT FILE FOR NPT DYNAMICS OF SOLVATED GLOBULAR PROTEIN
 TITLE>  *
     48112  EXT
         1         1  SER       N               7.2343288005      -19.3438455283      -16.1757927048  PROA      3               0.0000000000
         2         1  SER       HT1             2.4092138846       -0.5796144732        1.9424868065  PROA      3               0.0000000000
         3         1  SER       HT2             1.1212192343       -1.2813090526       -0.3294225705  PROA      3               0.0000000000
         4         1  SER       HT3             1.7474879735       -0.3449442699       -0.4467440973  PROA      3               0.0000000000
         5         1  SER       CA             -1.7381606984       12.3693196894       11.3198523175  PROA      3               0.0000000000
"""
print('Parsing CHARMM forces...')
lines = charmm_output.split('\n')
for index in range(len(lines)):
    if 'CHARMM>    print coor comp' in lines[index]:
        print('FOUND')
        print(lines[index+6])
        elements = lines[index+6].split()
        print(elements)
        natoms = int(elements[0])
        firstline = index + 7
        break
charmm_forces = np.zeros([natoms,3], np.float32)
for (atom_index, line_index) in enumerate(range(firstline,firstline+natoms)):
    line = lines[line_index]
    elements = lines[line_index].split()
    charmm_forces[atom_index,0] = float(elements[4])
    charmm_forces[atom_index,1] = float(elements[5])
    charmm_forces[atom_index,2] = float(elements[6])
charmm_forces = u.Quantity(charmm_forces, u.kilocalories_per_mole / u.angstroms)
print(charmm_forces)

prefix = 'dhfr' # Directory where CHARMM input files are stored
psf = app.CharmmPsfFile(os.path.join(prefix, 'step3_pbcsetup.psf'))
# Taken from output of CHARMM run
psf.setBox(8*u.nanometers, 8*u.nanometers, 8*u.nanometers) # NOTE: These are hard-coded!
crd = app.CharmmCrdFile(os.path.join(prefix, 'step3_pbcsetup.crd'))
params = app.CharmmParameterSet(os.path.join(prefix, 'toppar/par_all36_prot.prm'),
                                os.path.join(prefix, 'toppar/toppar_water_ions.str'))

system = psf.createSystem(params, nonbondedMethod=app.PME,
        nonbondedCutoff=12*u.angstroms, switchDistance=10*u.angstroms)

for force in system.getForces():
    if isinstance(force, mm.CustomNonbondedForce):
        #print('CustomNonbondedForce: %s' % force.getUseSwitchingFunction())
        #print('LRC? %s' % force.getUseLongRangeCorrection())
        force.setUseLongRangeCorrection(False)
    elif isinstance(force, mm.NonbondedForce):
        #print('NonbondedForce: %s' % force.getUseSwitchingFunction())
        #print('LRC? %s' % force.getUseDispersionCorrection())
        force.setUseDispersionCorrection(False)
        force.setPMEParameters(1.0/0.34, 90, 90, 90) # NOTE: These are hard-coded!
pmdparm = pmd.load_file(os.path.join(prefix,'step3_pbcsetup.psf'))
pmdparm.positions = crd.positions
pmdparm.box = [80, 80, 80, 90, 90, 90]

# Print PME parameters
integrator = mm.VerletIntegrator(1.0 * u.femtoseconds)
context = mm.Context(system, integrator)
context.setPositions(crd.positions)
for force in system.getForces():
    if isinstance(force, mm.NonbondedForce):
        break
integrator.step(1)
print(force.getPMEParametersInContext(context))
del context, integrator

# CHARMM energy: From docker evaluation
# TODO: Pull these components in with a Python script.
"""
ENER ENR:  Eval#     ENERgy      Delta-E         GRMS
ENER INTERN:          BONDs       ANGLes       UREY-b    DIHEdrals    IMPRopers
ENER CROSS:           CMAPs        PMF1D        PMF2D        PRIMO
ENER EXTERN:        VDWaals         ELEC       HBONds          ASP         USER
ENER IMAGES:        IMNBvdw       IMELec       IMHBnd       RXNField    EXTElec
ENER EWALD:          EWKSum       EWSElf       EWEXcl       EWQCor       EWUTil
 ----------       ---------    ---------    ---------    ---------    ---------
ENER>        0-163043.99835      0.00000      5.02279
ENER INTERN>     6337.99813   4236.12181     54.30685   1726.66813     21.86301
ENER CROSS>       -21.48984      0.00000      0.00000      0.00000
ENER EXTERN>    20161.20647-164737.82886      0.00000      0.00000      0.00000
ENER IMAGES>      243.39096  -5318.48694      0.00000      0.00000      0.00000
ENER EWALD>       4130.5989-1021718.0599  991839.7129       0.0000       0.0000
"""
charmm_energy = dict()
charmm_energy['Bond'] = 6337.99813
charmm_energy['Angle'] = 4236.12181 + 54.30685
charmm_energy['Dihedral'] = 1726.66813 + 21.86301 + -21.48984
charmm_energy['Nonbonded'] = 20161.20647 + -164737.82886 + 243.39096  -5318.48694 + 4130.5989 -1021718.0599 + 991839.7129
charmm_energy['Total'] = -163043.99835

# Form CHARMM energy components
charmm_energy = dict()
charmm_energy['Bond'] = charmm_energy_components['BONDs'] * u.kilocalories_per_mole
charmm_energy['Angle'] = charmm_energy_components['ANGLes'] * u.kilocalories_per_mole
charmm_energy['Urey-Bradley'] = charmm_energy_components['UREY-b'] * u.kilocalories_per_mole
charmm_energy['Dihedrals'] = charmm_energy_components['DIHEdrals'] * u.kilocalories_per_mole
charmm_energy['Impropers'] = charmm_energy_components['IMPRopers'] * u.kilocalories_per_mole
charmm_energy['CMAP'] = charmm_energy_components['CMAPs'] * u.kilocalories_per_mole
charmm_energy['Nonbonded'] = \
    + charmm_energy_components['VDWaals'] * u.kilocalories_per_mole \
    + charmm_energy_components['ELEC'] * u.kilocalories_per_mole \
    + charmm_energy_components['IMNBvdw'] * u.kilocalories_per_mole \
    + charmm_energy_components['IMELec'] * u.kilocalories_per_mole \
    + charmm_energy_components['EWKSum'] * u.kilocalories_per_mole \
    + charmm_energy_components['EWSElf'] * u.kilocalories_per_mole \
    + charmm_energy_components['EWEXcl'] * u.kilocalories_per_mole

charmm_energy['Total'] = charmm_energy_components['ENERgy'] * u.kilocalories_per_mole


total = 0.0 * u.kilocalories_per_mole
force_terms = ['Bond', 'Angle', 'Urey-Bradley', 'Dihedrals', 'Impropers', 'CMAP', 'Nonbonded']
for key in force_terms:
    total += charmm_energy[key]
print(charmm_energy['Total'], total)
omm_e = pmd.openmm.energy_decomposition_system(pmdparm, system)
# Attach proper units
for (index, (name, e)) in enumerate(omm_e):
    omm_e[index] = (name, e * u.kilocalories_per_mole)

# OpenMM energy
openmm_energy = dict()
openmm_energy['Bond'] = omm_e[0][1]
openmm_energy['Angle'] = omm_e[1][1]
openmm_energy['Urey-Bradley'] = omm_e[2][1]
openmm_energy['Dihedrals'] = omm_e[3][1]
openmm_energy['Impropers'] = omm_e[4][1]
openmm_energy['CMAP'] = omm_e[5][1]
openmm_energy['Nonbonded'] = omm_e[6][1] + omm_e[7][1]
openmm_energy['Total'] = openmm_energy['Bond'] + openmm_energy['Angle'] + openmm_energy['Urey-Bradley'] + openmm_energy['Dihedrals'] + openmm_energy['Impropers'] + openmm_energy['CMAP'] + openmm_energy['Nonbonded']

print('OpenMM Energy is %s' % omm_e)

# Now do the comparisons
print('Output in kJ/mol')
print('%-20s | %-15s | %-15s' % ('Component', 'CHARMM', 'OpenMM'))
print('-'*56)
total = 0
for name in force_terms:
    print('%-20s | %15.2f | %15.2f' % (name, charmm_energy[name] / u.kilojoules_per_mole, openmm_energy[name] / u.kilojoules_per_mole))
print('-'*56)
print('%-20s | %15.2f | %15.2f' % ('Total', charmm_energy['Total'] / u.kilojoules_per_mole, openmm_energy['Total'] / u.kilojoules_per_mole))
print('-'*56)
